Greedy Algorithms
Coins with change, 25, 10, 5, 1 would give correct change
Coins of different denomination 12, 5, 1 giving change for 15
Optimized = 3 with 5,5,5
Greedy = 4 with 12, 1, 1, 1

Discussion 4/6
1pm lab instructor Neeraj Kumar = neeraj@cs.ucsb.edu
O() 		f(n) < = c g(n)
omega() 	f(n) > = c g(n)
theda()		f(n) = c g(n)

log(ab) = loga + logb
log(a/b) = loga - logb
log(a^b) = bloga



Huffman codes

Toy text file, 100k char key
F.L.C  = fixed length encoding
V.L.C = variable length coding
e = dot
t = dash
a = dot - dash

Char 	a	b	c	d	e	f	<- 800 k bits
Freq	45	13	12	16	9	5	<- k

F.L.C	000	001	010	011	100	101	<- 300 k bits
V.L.C	0	101	100	111	1101	1100	<- 224 k bits
^^^Huffman

__________________________________________

Prefix-free Property
Coding of one can not be the prefix of another 
ex) 0 and 00 not allowed, but the VLC above is valid




Binary tree with 0 and 1 traversals showing Optimal prefix code


Code length of character = depth of tree
Code length(x) = dT(x)

Input 		character set C
		Freq f(x), x exists in C

Output		Code table = binary tree T
		Code length(x) = dT(x)

Compressed File size
	B(T) = ∑ f(x) dT(x)
		^X exists in C

All nodes in optimal tree must be full (node has 0 or 2 children)
ex) in pic, tree on left is not valid, tree on right is valid



Char 	a	b	c	d	e	f	
Freq	45	13	12	16	9	5
	

This takes the most freq letter with the lowest depth, and the least frequency at the largest  depth

Not efficient way to do it





Sort freq in ascending order
f	e	c	b	d	e
5	9	12	13	16	45

Take 2 smallest values and connect them to a parent node with the summ added in that
Repeat this step until tree is done being built

Q <- C
For i = 1 to n-1
	z <- new node()
	x <- lef(z) <- delete min(Q)
	y <- reight(z) <- delete mi (Q)
	f(z) <- f(x) + f(y)
insert(Q,z)

Runtime
O(nlogn)












Proof that huffman is the shit

x,y : smallest freq char
Argument:
Suppose x,y are two lowest freq char in C
Then there is an optimal code in which x and y have equal and maximum code length and have the code different only in the last bit

a,b in optimal tree 
Proof:
Suppose instead char with max depth of common parent are a, b


f(x) <= f(y)
f(a) <= f(b)

f(x) <=F(a)
f(y) <= f(b)

B(T) = B(T’)
= ∑ f(x) dT(x)-∑ f(x) dT’(x)
=[ f(x) dT(x) + f(a) dT(a)] - [ f(x) dT’(x) + f(a) dT’(a)]
                                      - [ f(x) dT(a) + f(a) dT(x)]
=[f(a) - f(x)][dT(a) - dT(x)] 
    >= 0






















4/12 lecture
Programing assignment due may 3

Character set C

If a and b freq is large in first half of file, and cd is in the second half of file, it would be difficult to adapt huffman on the fly, so you need to read the whole data first.
a b   				c d
Word level
Lossy

Greedy Algorithms
Dijkstra’s shortest paths
Minimum spanning tree

Kruskals
























4/17 lecture

Divide & Conquer
Divide problem into subproblem
Solve subproblems
Combine subproblem solutions to solve original problem

Examples of divide and conquer algorithms
Binary search
Merge sort
Quick sort
Matrix multiplication
Median finding


X = number we are trying to find
P, Q = beginning and end index
A = array
______________________________________
Bin Search (A, P, Q, X)
If P>Q return -1
r = floor[(P+Q/2)]
If x == A[P] return P
Else if x < A[P] BinSearch(A,r,Q,X)
Else BinSearch(A, r+1, Q, X)

T(n) = worse-case returned gn on input g size n
T(n) = T(n/2) + O(1)			O(1) could be c, as a constant
=> T(n) = Theda(logn)
________________________________________
MergeSort(a,p,q)
If p>= q return a
r = [(p+q)/2]
Mergesort(a,p,r)
MERGE(a,p,q,r)

T(n) = worst-case routine g on input g size n
T(n) = 2T(n/2) + O(n)
=> theda(nlogn)
______________________________________



Multiply 2 numbers
A	   751849
B	x 221465
	-------------
Using “elementary school” multiplication, Run time is theta(n^2)


x = 4729, y = 1326

x = (47*10^2 + 29)
y = (13*10^2 + 26)

x = ab = a*2^(n/2) + b
y = cd = c*2^(n/2) + d

xy = [a*2^(n/2) + b] [c*2^(n/2) + d]
     = ac2^(n) + ad2^(n/2) + bc2^(n/2) + bd

T(n) = 4T(n/2) + O(n)
=>theta(n^2)

Karatsuba’s algorithm
= ac2^(n) + ad2^(n/2) + bc2^(n/2) + bd
= ac2^n + (ad + bc)^(n/2) + bd

ac
bd
(a-b)(c-d) = ac + bd - (ad + bc)
T(n) =  3T(n/2) + O(n)
=> O(n^(1.59))













Solving Recurrences 
Recurrence solving by expansion
Tree method
Induction / guess a plug
Master Method
T(n)     = 2T(n/2) + cn		T(n) = 1 for appropriate value
	= 2[2T(n/2)+ cn/2] + cn
= 2^2 * T(n/(2^2)) + 2cn
= 2^2 * [2T(n/(2^3))+ cn/(2^2)] + 2cn
= 2^3 * T(n/w^(3)) + 3cn 
=> 2^(logn) * T(1) + logn * cn
	= n + cnlogn
T(n) = O(nlogn)































_______________________________________
4/24
_______________________________________

Median Finding
Selection

5, 25, 7, 90, 100, 2, 32, 20

Sort numbers above

2, 5, 7, 20, 25, 32, 90, 100		20 or 25 can be median
Rank(x): position of x in sorted order
	ex) 20 -> 4, 100 -> 8
Define median as ceil(n/2)
Find min:	 n-1 comparisons
Find max:	 n-1 comparisons

If |A| = 1 return min = max = A(0)
DIVIDE A into two equal parts A1, A2
Recursively call: (Min1, Max1) = MinMax(A1)
   (Min2, Max2) = MinMax(A2)
If Min1 <= Min2, then return Min = Min1
	Else Min = Min2
If Max1 >= Max2, then return Max= Max1
	Else Max = Max2

T(n) = 2T(n/2) + 2
        = 3n/2 - 2

Linear time algorithm for selecting rank k item

Select(k)
Divide Items into floor(n/5) groups of 5 items
Find the median of each group
Recursively use Select to find median of floor(n/5) group medians
Partition item last using median of medians (step 3)
Let “small” side have S items, S sides (n - S) items
If k<= S, select(k) on small side
	Else select (k - S) on large side




100 21
101 32
102 6
103 23
104 9
109 5

3 59
56 100
57 100
6 174
2 176
4 185
7 199
8 205
9 217
1 242
5 250
0 431
58 505
59 705
